#! /bin/bash

#-------------------------------------------------------------------
Help(){
cat<<EOF

Usage: maketemplate [OPTION] <function_name>

  --help                    output help information
  --raw   		    create a template function for raw TTree analysis
  --merge  		    create a template function for merged TTree analysis
  --event		    create a template function for event TTree analysis	   

EOF
  exit 1
}

#-------------------------------------------------------------------
NewTemplateRaw(){
#-------------------------------------------------------------------
cat > $1.C <<EOF
/*   \$Id: $1.h, $date MWDC_ana Raw$
 *--------------------------------------------------------
 *  Author(s):
 *
 *--------------------------------------------------------
*/

#include "TTree.h"
#include "TFile.h"
#include "TROOT.h"
#include "TCanvas.h"
#include "TH1F.h"
#include "CrateInfo.h"
#include "BoardInfo.h"
#include "utility.h"

int $1(const char* datadir,const char* outfile)
{
  //read the config file which include channelmapping info
  TString file_config=TString(datadir)+"/crate.json";
  CrateInfo* info=Utility::read_config(file_config.Data(),"mapping");
  info->Print();

  //check the structure of root file,check the consitency between root file and config file
  TString file_data=TString(datadir)+"/"+outfile;  
  TFile* file_out=new TFile(file_data,"update");
  if(!file_out){
    printf("open file error: %s\n",outfile);
    exit(1);
  }
  TDirectory* raw_dir=file_out->GetDirectory("raw");
  if(!raw_dir){
    printf("dir \"raw\" not exist in this file.invoke convert_hptdc first\n");
    exit(1);
  }
  
  TList* keys=raw_dir->GetListOfKeys();
  int boardnum=info->GetBoardNum();
  int mwdcnum=0;
  int tofnum=0;
  BoardInfo** boardinfo=new BoardInfo*[boardnum]{};
  for(int i=0;i<boardnum;i++){
    boardinfo[i]=info->GetBoardInfo(i);
    switch (boardinfo[i]->GetType()) {
	  case EMWDC:
	    mwdcnum++;
	    break;
	  case ETOF:
	    tofnum++;
	  default:
	    break;
    }
    if(!keys->FindObject(boardinfo[i]->GetName())){
	    printf("error missing raw tree: you may not use the same config file\n");
	    exit(1);
    }
  }

  //init and get corresponding tree from root file
  TTree** 	tree_in_mwdc=new TTree*[mwdcnum]{};
  BoardInfo**	mwdc_boardinfo=new BoardInfo*[mwdcnum]{};
  Int_t*	mwdc_eventid=new Int_t[mwdcnum]{};
  Int_t*	mwdc_bunchid=new Int_t[mwdcnum]{};
  Char_t* mwdc_eventflag=new Char_t[mwdcnum]{};
  ChannelMap** 	mwdc_leading_raw=new ChannelMap*[mwdcnum]{};
  ChannelMap** 	mwdc_trailing_raw=new ChannelMap*[mwdcnum]{};
  
  TTree** 	tree_in_tof=new TTree*[tofnum]{};
  BoardInfo**	tof_boardinfo=new BoardInfo*[tofnum]{};
  Char_t* tof_eventflag=new Char_t[tofnum]{};
  Int_t*	tof_eventid=new Int_t[tofnum]{};
  Int_t*	tof_bunchid=new Int_t[tofnum]{};
  ChannelMap** 	tof_timeleading_raw=new ChannelMap*[tofnum]{};
  ChannelMap** 	tof_timetrailing_raw=new ChannelMap*[tofnum]{};
  ChannelMap** 	tof_totleading_raw=new ChannelMap*[tofnum]{};
  ChannelMap** 	tof_tottrailing_raw=new ChannelMap*[tofnum]{};
  
  TTree** 	tree_in=new TTree*[boardnum]{};
  mwdcnum=0;tofnum=0;
  for(int i=0;i<boardnum;i++){
    switch (boardinfo[i]->GetType()){
      case EMWDC:
	raw_dir->GetObject(boardinfo[i]->GetName(),tree_in_mwdc[mwdcnum++]);
	mwdc_boardinfo[mwdcnum-1]=boardinfo[i];
	tree_in[i]=tree_in_mwdc[mwdcnum-1];
  tree_in[i]->SetBranchAddress("event_flag",&mwdc_eventflag[mwdcnum-1]);	
	tree_in[i]->SetBranchAddress("event_id",&mwdc_eventid[mwdcnum-1]);
	tree_in[i]->SetBranchAddress("bunch_id",&mwdc_bunchid[mwdcnum-1]);
	tree_in[i]->SetBranchAddress("leading_raw",&mwdc_leading_raw[mwdcnum-1]);
	tree_in[i]->SetBranchAddress("trailing_raw",&mwdc_trailing_raw[mwdcnum-1]);
  // Activate the referenced branches
  tree_in[i]->SetBranchStatus("*",0);
  //tree_in[i]->SetBranchStatus("event_flag",1);
  //tree_in[i]->SetBranchStatus("event_id",1);
  //tree_in[i]->SetBranchStatus("bunch_id",1);
  //tree_in[i]->SetBranchStatus("leading_raw",1);
  //tree_in[i]->SetBranchStatus("trailing_raw",1);

	mwdc_boardinfo[mwdcnum-1]->Print();
	break;
      case ETOF:
	raw_dir->GetObject(boardinfo[i]->GetName(),tree_in_tof[tofnum++]);
	tof_boardinfo[tofnum-1]=boardinfo[i];
	tree_in[i]=tree_in_tof[tofnum-1];	
  tree_in[i]->SetBranchAddress("event_flag",&tof_eventflag[tofnum-1]);
	tree_in[i]->SetBranchAddress("event_id",&tof_eventid[tofnum-1]);
	tree_in[i]->SetBranchAddress("bunch_id",&tof_bunchid[tofnum-1]);
	tree_in[i]->SetBranchAddress("time_leading_raw",&tof_timeleading_raw[tofnum-1]);
	tree_in[i]->SetBranchAddress("time_trailing_raw",&tof_timetrailing_raw[tofnum-1]);
	tree_in[i]->SetBranchAddress("tot_leading_raw",&tof_totleading_raw[tofnum-1]);
	tree_in[i]->SetBranchAddress("tot_trailing_raw",&tof_tottrailing_raw[tofnum-1]);
  // Activate the referenced branches
  tree_in[i]->SetBranchStatus("*",0);
  //tree_in[i]->SetBranchStatus("event_flag",1);
  //tree_in[i]->SetBranchStatus("event_id",1);
  //tree_in[i]->SetBranchStatus("bunch_id",1);
  //tree_in[i]->SetBranchStatus("time_leading_raw",1);
  //tree_in[i]->SetBranchStatus("time_trailing_raw",1);
  //tree_in[i]->SetBranchStatus("tot_leading_raw",1);
  //tree_in[i]->SetBranchStatus("tot_trailing_raw",1);

	tof_boardinfo[tofnum-1]->Print();
	break;
      default:
	break;
    }
  }
  //init
  Int_t temp_entries;
  Int_t entries=tree_in[0]->GetEntriesFast();
  for(int i=0;i<boardnum;i++){
    temp_entries=tree_in[i]->GetEntriesFast();
    if(temp_entries<entries){
      entries=temp_entries;
    }
  }
  
  ChannelMap::iterator it;  
  //for(int i=0;i<100;i++){
  for(int i=0;i<entries;i++){
    if(!((i+1)%5000)){
      printf("%d events processed\n",i+1);
    }
    //
    for(int j=0;j<boardnum;j++){
      tree_in[j]->GetEntry(i);
    }
    //process
    for(int j=0;j<mwdcnum;j++){
      for(it=mwdc_leading_raw[j]->begin();it!=mwdc_leading_raw[j]->end();it++){
	
      }
      for(it=mwdc_trailing_raw[j]->begin();it!=mwdc_trailing_raw[j]->end();it++){

      }
    }

    for(int j=0;j<tofnum;j++){
      for(it=tof_timeleading_raw[j]->begin();it!=tof_timeleading_raw[j]->end();it++){

      }
      for(it=tof_timetrailing_raw[j]->begin();it!=tof_timetrailing_raw[j]->end();it++){

      }
      for(it=tof_totleading_raw[j]->begin();it!=tof_totleading_raw[j]->end();it++){

      }
      for(it=tof_tottrailing_raw[j]->begin();it!=tof_tottrailing_raw[j]->end();it++){

      }
    }
  }
  
  printf("%d events processed totally!\n",entries);
  
  //dir "histogram"
  TDirectory* dir_hist=file_out->GetDirectory("raw/histogram");
  if(!dir_hist){
    dir_hist=file_out->mkdir("raw/histogram");
    if(!dir_hist){
      printf("error!can't mkdir \"raw/hitogram\" in %s\n",outfile);
      exit(1);
    }
    dir_hist=file_out->GetDirectory("raw/histogram");
  }
  dir_hist->cd();
  //
  delete file_out;
  delete [] tree_in_mwdc;
  delete [] mwdc_boardinfo;
  delete [] mwdc_eventflag;
  delete [] mwdc_eventid;
  delete [] mwdc_bunchid;
  delete [] mwdc_leading_raw;
  delete [] mwdc_trailing_raw;
  
  delete [] tree_in_tof;
  delete [] tof_boardinfo;
  delete [] tof_eventflag;
  delete [] tof_eventid;
  delete [] tof_bunchid;
  delete [] tof_timeleading_raw;
  delete [] tof_timetrailing_raw;
  delete [] tof_totleading_raw;
  delete [] tof_tottrailing_raw;
  
  delete [] tree_in;
  delete [] boardinfo;
  //
  delete info;
  
  return 0;
}
EOF
}

#-------------------------------------------------------------------
NewTemplateMerge()
{
cat > $1.C << EOF
/*   \$Id: $1.h, $date MWDC_ana Merge$
 *--------------------------------------------------------
 *  Author(s):
 *
 *--------------------------------------------------------
*/

#include "TTree.h"
#include "TFile.h"
#include "TROOT.h"
#include "TCanvas.h"
#include "TH1F.h"
#include "CrateInfo.h"
#include "BoardInfo.h"
#include "utility.h"

int $1(const char* datadir,const char* outfile)
{
  //
  TString label_location[2]={"Down","Up"};
  TString label_direction[3]={"X","Y","U"};
/*
  //define histogram
  std::vector<TH1F*> histrepo[2];
  TH1* htemp;
  for(int i=0;i<2;i++){
    for(int j=0;j<3;j++){
      htemp=(TH1*)gROOT->FindObject("h"+label_direction[j]+"_"+label_location[i]+"_"+"multihit");
      if(htemp)	{
	delete htemp;
      }
      histrepo[i].push_back(new TH1F("h"+label_direction[j]+"_"+label_location[i]+"_"+"multihit",label_direction[j]+"_"+label_location[i]+"_"+"multihit",11,-0.5,10.5));
    }
  }
*/
  //
  TString file_data=TString(datadir)+"/"+outfile;  
  TFile* file_out=new TFile(file_data,"update");
  if(!file_out){
    printf("open file error: %s\n",outfile);
    exit(1);
  }
  //
  TTree *tree_mwdc,*tree_tof;
  file_out->GetObject("merge/mwdc",tree_mwdc);
  file_out->GetObject("merge/tof",tree_tof);
  
  ChannelMap *mwdc_leading=0,*mwdc_trailing=0;
  tree_mwdc->SetBranchAddress("leading_raw",&mwdc_leading);
  tree_mwdc->SetBranchAddress("trailing_raw",&mwdc_trailing);
  // Activate the referenced branches
  tree_mwdc->SetBranchStatus("*",0);
  //tree_mwdc->SetBranchStatus("leading_raw",1);
  //tree_mwdc->SetBranchStatus("trailing_raw",1);

  ChannelMap *tof_timeleading=0,*tof_timetrailing=0,*tof_totleading=0,*tof_tottrailing=0;
  tree_tof->SetBranchAddress("time_leading_raw",&tof_timeleading);
  tree_tof->SetBranchAddress("time_trailing_raw",&tof_timetrailing);
  tree_tof->SetBranchAddress("tot_leading_raw",&tof_totleading);
  tree_tof->SetBranchAddress("tot_trailing_raw",&tof_tottrailing);
  // Activate the referenced branches
  tree_tof->SetBranchStatus("*",0);
  //tree_tof->SetBranchStatus("time_leading_raw",1);
  //tree_tof->SetBranchStatus("time_trailing_raw",1);
  //tree_tof->SetBranchStatus("tot_leading_raw",1);
  //tree_tof->SetBranchStatus("tot_trailing_raw",1);

  //
  int entries=tree_mwdc->GetEntriesFast();
  ChannelMap::iterator it;
  UChar_t type,location,direction;
  UShort_t index;
  //for(int i=0;i<100;i++){
  for(int i=0;i<entries;i++){
    if(!((i+1)%5000)){
      printf("%d events analyzed\n",i+1);
    }
    tree_mwdc->GetEntry(i);
    tree_tof->GetEntry(i);
    //
    for(it=mwdc_leading->begin();it!=mwdc_leading->end();it++){
      Encoding::Decode(it->first,type,location,direction,index);
      if (type!=EMWDC) {
	printf("event_%d:MWDC unmatched type\n",i+1);
      }
    }
    for(it=mwdc_trailing->begin();it!=mwdc_trailing->end();it++){
      Encoding::Decode(it->first,type,location,direction,index);
      if (type!=EMWDC) {
	printf("event_%d:MWDC unmatched type\n",i+1);
      }
    }
    //
    for(it=tof_timeleading->begin();it!=tof_timeleading->end();it++){
      Encoding::Decode(it->first,type,location,direction,index);
      if (type!=ETOF) {
	printf("event_%d:TOF unmatched type\n",i+1);
      }
    }
    for(it=tof_timetrailing->begin();it!=tof_timetrailing->end();it++){
      Encoding::Decode(it->first,type,location,direction,index);
      if (type!=ETOF) {
	printf("event_%d:TOF unmatched type\n",i+1);
      }
    }
    for(it=tof_totleading->begin();it!=tof_totleading->end();it++){
      Encoding::Decode(it->first,type,location,direction,index);
      if (type!=ETOF) {
	printf("event_%d:TOF unmatched type\n",i+1);
      }
    }
    for(it=tof_tottrailing->begin();it!=tof_tottrailing->end();it++){
      Encoding::Decode(it->first,type,location,direction,index);
      if (type!=ETOF) {
	printf("event_%d:TOF unmatched type\n",i+1);
      }
    }
  }
  
  printf("%d events processed totally\n",entries);
  //dir "histogram"
  TDirectory* dir_hist=file_out->GetDirectory("merge/histogram");
  if(!dir_hist){
    dir_hist=file_out->mkdir("merge/histogram");
    if(!dir_hist){
      printf("error!can't mkdir \"merge/hitogram\" in %s\n",outfile);
      exit(1);
    }
    dir_hist=file_out->GetDirectory("merge/histogram");
  }
  dir_hist->cd();
  //
  const Int_t nx=1,ny=1;
  TCanvas *can = (TCanvas*) gROOT->FindObject("can");
  if(can) delete can;
  can=new TCanvas("can","can",300*nx,300*ny);
  can->Divide(nx,ny,0,0,3);
  for(int i=0;i<ny;i++){
    for(int j=0;j<nx;j++){
      can->cd(nx*i+j+1);
      /*
      histrepo[i][j]->DrawCopy();
      histrepo[i][j]->Write(0,TObject::kOverwrite);
      */
    }
  }
  //
  delete file_out;
  
  return 0;
}

EOF
}
#-------------------------------------------------------------------
if [ '--help' == $1 ];then
  Help
fi
if [ $# != 2 ];then
  echo "Must give a name for the new function:"
  echo ""
  echo "    maketemplate $1 aName"
  exit 1
fi

#-------------------------------------------------------------------
date=`date --rfc-3339=seconds`

#-------------------------------------------------------------------
case $1 in
  --raw)
    NewTemplateRaw $2
    ;;
  --merge)
    NewTemplateMerge $2
    ;;
  --event)
    NewTemplateEvent $2
    ;;
  --help)
    Help
    ;;
  *)
    echo "maketemplate: '$1' is not a maketemplate command"
    echo ""
    echo "    See 'maketemplate --help'"
    ;;
esac

